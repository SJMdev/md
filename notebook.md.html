# Thesis
!!! note
    The following is a list of items that I learned from writing my thesis in c++17 on ubuntu 16.04.
## programming notes

### deleting items from the current vector
Asteroids can be hit by bullets. If this is the case, they should be destroyed. We implemented the following logic:
~~~~~~~~~~~~~~ C
for (auto &asteroid: d_asteroids)
{
    for(auto &bullet: d_bullets)
    {
        if (asteroid.contains(bullet.hitbox()))
        {
            asteroid.erase();
            bullet.erase();
        }
    }
}
~~~~~~~~~~~~~~
The astute reader will note that something is going wrong here: what happens if you erase the asteroid that you are currently iterating over? **The program crashes***.
so it did. we fixed this by marking asteroids and bullets for destruction, and destroying them later when not iterating over them (I think. I need to look this up).

### Testing multiple algorithms: "case" in point
We wanted to use different learning algorithms. However, these learning algorithms required different network architectures. These algorithms were mostly similar in structure and data flow,
thus we implemented `case` switches for these algorithms and provided the constructor of the `Network`instance with a parameter describing which algorithm we were currently using.

Unfortunately, as it always does, the core logic of these algorithms diverges pretty fast. It ended up with us writing a whole lot of state management and case logic in each function of the `Network` class,
which in turn lead to less clarity (and a lot of mistakes).

Had we used some form of inheritance for the Network class, It would have made it much easier to figure out where or what went wrong. It would allow us to use the core of the class for each algorithm (saving the network, exploration, etc.)
but instantiate different Network-type classes, each with their own behavior.

It would perhaps have also made it easier to add benchmarking, as we could just instantiate a benchmarking `Network`.

### Using pointers in c++
c++ has references: these are aliases for existing variables. Once a reference is initialized to a certain variable, it cannot be changed. It can also not be NULL.
In general, it seems very wise to use references to use references as function arguments: it avoids a local copy in the function, is immutable (so we know what object we're talking about)
and allows for code clarity in function definitions (as references do not need to be dereferenced like pointers).

All of these points make it seem that pointers are mostly obsolete in c++. I would argue that this is mostly true, but I want to talk about a problem Niels and I ran in to during development.

Imagine having a `Window` class. All it does is create a window for the user to look at the program. We used the `SFML` library to extract some of the complicated logic away. On our local machines,
this worked perfectly fine. Subsequently, we then decided we should also be able to run the application without the window, as it would probably reduce computational load (and having a lot of windows open does not lead to higher usability of the machine).
In our implementation, we still created the window, but never called the `window.show()` member function. This was the exact problem.

When we tried to launch our application on peregrine, we were met by an X11 error. We concluded that the necessary drivers to launch a window (managed by SFML -> OpenGL -> system calls) were not installed. Not that weird, seeing as how peregrine is just a computing cluster,
and has no need for these drivers. However, we had no idea how to install them, and even if we knew how, we probably weren't allowed to do so (peregrine is a large cluster used by many people).  However, we still needed a `Window` instance, as it also
contained the game loop and state logic of the game. So how do we instantiate the `Window` Class without actually launching a window?

To solve this problem, we used the following (and in hindsight, extremely obvious) solution: instantiate the `Window` class with a window pointer, and either set the pointer to a window or leave it NULL.

### the singleton class pattern
We wanted to change certain parameters of our project between runs (e.g. the network architecture, or the bullet and ship speed, that sort of thing). However, because we decided to write our project in c++,
we had to recompile on every change. This quickly became unfeasible after compiling took more than 10 minutes (which is something we fixed later as well!). 

From practical experience with video game tinkering, I had seen many .cfg files up until this point. We realized that if we had a config file for all these parameters, we could just feed all the parameters at runtime,
and change them at our own leisure. However, we ran into implementation problems relatively quickly. We had many instances of several classes, mostly nested calls. We could instantiate a `Constants` object in every class,
but that also seemed not the correct approachc. How do we make something globally accessible in nested functions and classes?

We used the `extern Constants constants` approach. It is a janky solution compared to the singleton class pattern, but it worked for us.


# Trying to learn web development

Markdown is pretty useful. It seems like a stripped down version of lateX with less explicit and generalizability. I am currently using some sort of 
.md.html file which automatically converts markdown to html (I think).


## Hosting a plain html site.

### Learning html
As far as I understand, the web mostly consists of three types of files: .html, .css and .js files. HTML is a simple markup language, and it reminds me of XML. It defines the general layout of the website. CSS is used to style the website, and javascript
is used to serve dynamic content (such as the website changing based on user input). HTML has predefined keywords and statements, also known as **tags**. As of yet, I understand the following:

- `<p>`, or paragraph.
- `body`, which contains all the so called 'elements'.
- `audio`, which provides a means to play audio. We used this in the KAT practical demo.

Personally, I find HTML difficult to read. The use of the < and > brackets and scope determination by using a closing statement does not help. 

### serving plain html
I have no idea. I recall doing something with Express.js.

## serving the Markdown file as HTML
I am currently using a github page in order to more easily host it. I have a plain index.html file which contains "hello world". In doing so, it still allows me to access the [.md.html file](https://sjmdev.github.io/md/notebook.md.html)
 without actually requiring to use the index.html file.

### cool stuff
 Additionally, it allows for LateX-like code blocks such as the following:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C
void insertion_sort(vector<int> vector, int length) 
{
    for (int idx = 0; idx != length; ++i) 
    {
       ...
    }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Which is pretty useful.




#  Game development

## Developing an ECS 
First, I'm doing it my way. Afterwards, Let's try to do some template instantiation stuff.

### The World
the World manages all entities, and creation and destruction. some small thinking points:

!!! note
    Why not just use a vector of entities?
I think(?) because it is cheaper to keep track of entities via pointer (and some other template stuff). Therefore, in the  `World` object, we have a `createEntity` function,
which returns a pointer to an entity. 

!!! note
    Why is this a plain pointer?
I genuinely do not know yet. Will weak or shared_ptr help?

### Entities 
the gist of the ECS is that an Entity is dumb. It has an ID by which it is referred. it also has components. I am currently envisioning it as a vector of type `Component`,
but I'm not sure yet!


## Using Unity as a stepping stone
Unity's game engine is pretty useful and cookie cutter: it empowers users to quickly develop prototypes (and actual games).

## Particle effects 
I have always been enamored with particle effects in games, especially when well done. The bomb cloud from the wind waker is one of my favorite effects of all time.
You can see the effect recreated [here](https://www.youtube.com/watch?v=0IrCggoJCno). In the coming weeks, I will be trying to recreate the effects myself according to this guide (which seems like a proper introduction to the subject).
Furthermore, I want to create some sort of `Window` where I can play the particle effect.  

Steps already taken:
1. Installing blender
2. Create a plane which emits particles!

The result can be seen in in the following figure: 

![Figure [particle1]: A gif showing particles being emitted from a plane](gifs/particlesystem.gif)




TODO:
3. Change the particles to something else.
4. Try to figure out whether the files can be exported.

## Lua Scripting
Similar to the configuration problems we faced in the bachelor thesis, I was always interested in the drag'n'drop programming interfaces like in unity or the unreal engine. In these engines, the developer can write some script (e.g. for movement)
and this script is then in some way converted to actual code? It seemed like magic to me. I vaguely knew of the term JIT compilation, but never really knew what that meant. I dabbled with lua scripting in the source engine for Dota 2 (specifically trying to recreate
my favorite Heroes of Newerth Hero, Chipper). I recently saw a blog about creating and using lua bindings in c++ (click [here](https://eliasdaler.wordpress.com/2013/10/11/lua_cpp_binder/). Additionally, [this](https://eliasdaler.wordpress.com/2015/08/10/using-lua-and-cpp-in-practice/) blog contains some real world
examples of using lua in c++.

### installing the lua libraries on windows.
There is a simple executable installer which you can grab off any search engine. This installs all the libraries and include folders etc.

setting up a visual studio project that can use lua takes a bit. In essence, you need to include this at the top of your file:

~~~~~~~~~~~~~~~~~~ C
extern "C" {
    # include "lua.h"
    # include "lauxlib.h"
    # include "lualib.h"
    }
~~~~~~~~~~~~~~~~
Because  all the lua libraries are written in C.

Furthermore, in the project's settings, you need to 
1. Include the lua libraries themselves (by adding them to the "include" directories)
2. Include the lua DLLs (by adding them to the "linker libraries")
3. Adding "lua.5.1.lib" to the included libraries 

Now, it sort of works. Additionally, I now sort of understand how useful template metaprogramming is: It allows you to dynamically create datatypes that we read in from the lua file.

next step is creating dynamic functions.


## Object Oriented Programming vs. Data Oriented Programming
There is a very interesting dichotomy in modern computing science (or even a schism from the OOP church). Object Oriented Programming is taught as the de facto standard for modern programming in general (as well as modern programming languages). However, It seems that often, the rigorous attachment to the OOP paradigm can lead to unfortunate situations, where practically solving a problem (i.e. "engineering" a solution) becomes secondhand towards the implementation style.  Elements of Object Oriented Programming can be very useful, such as inheritance, especially in cases such as GUI programming. An example of this is where some system will provide a base class `Button`, from which the user can derive other buttons, with different implementations based on the `virtual` (c++ term) methods in the base class, such as `onClick()`. While it can still be used as a button (as the new class is "implemented in terms of a" button), the effects that happen when clicking on the button can be implemented in a simple way. Furthermore, the idea of message passing between `Objects` (not objects in the programming term, but instances of different classes) allows the user to create a management dynamic (or a flow chart). However, OOP also comes at a cost: users will need to structure their program before starting to implement classes. Users will need to decide what scopes certain objects live in, so that they can communicate with other objects, and which objects carry responsibility for different parts of the implementation. However, I have always felt that eventually, this becomes a major roadblock in fast iteration: because objects live in a certain scope, and only provide certain functionality, their effectiveness is limited. While we can extend their usefulness by adding new methods or new fields (or placing them in a different scope), the structure of the program changes as well. Furthermore, maybe some responsibilities change over time of some objects. This to me leads me to believe that adhering to such a rigorous structure can hinder quick progression. Furthermore, because functionality like functions are now hidden within objects, we will need to instantiate an object in order to use those functions (or deal with static member functions of the class, or worse, trying to implement a singleton). In practical terms, this would mean dealing with an allocation on the stack (nitpicking, I know), or throwing stateful objects around between different functions. 

Another problem that I personally ran into is hierarchy problems, where certain objects are members of other objects. If your application does not have proper structure, a recurring problem will be that a data member will need access to another member of the class it is a member of. This means we do not only need to provide downstream information, but also upstream information requests. This very quickly leads to hacky implementations and weird state structures implemented outside of the class. This is of course also due to inexperience, but it can still be a problem for users, even if they know how to solve the problem at hand (so this is an __implementational__ detail).

Lastly, and this is a problem that I am unsure whether or not is fixable, is member accessors (or non-member accessors even). The Idea that a `class` object can contain immutable fields (i.e. `private`) is a clever idea: it means that the object can either carry hidden state that the users needs / wants to be shielded from. Furthermore, it allows a class to define member functions that only itself can use to operate on its own data, exposing an API that the user can use in order to interface with the object, but allowing for better control flow / logical structuring of the actual behavior that the API provides. However, it also seems that this idea of limiting access to an object originates from the idea that users do not know what do to with your object, and need to explicitly (or implicitly!) be told what and what NOT to do with the class. However, to me, it feels unnecessary to access fields such as `size` via a member function called `size()`. While the member function probably has guarantees that it will not change the member field itself (i.e. `size_t getSize() const;`) changing the size of, for example, a `string` in this way will lead to undefined behavior. The argument thus becomes: make it as hard as possible to shoot yourself in the foot. I think this has merit when you have to work in a large team, where not everyone is up-to-date or concerned with your specific part of the application, and thus the rules about any particular class are implicit within the usage of the class. However, it provides a lot of overhead (in my opinion) dealing with eventual stupidity of users. More concisely: you are not worrying about solving any particular problem with your code, but are more concerned with everything BUT solving the problem that the program should solve. 

Of course, there are more arguments to be made against object oriented programming, but most of them are implementational details (at least in the c++ camp of things). While for me, the problems that arise from the implementation are never problems I experience, I can understand the resistance against it.

I do want to admit that Object Oriented Programming in c++ is immensely useful in some circumstances, because of `RAII` (resource acquisition is initialization). Because an object will be destroyed when it leaves the scope, we can directly manage what happens when the objects destructor is called (`~Object()), which makes writing code that deals with memory and files a lot more managable than it ever was in C. At least, for me.



## solving some problems.
POD objects should be structs, and do not provide constructors. They are always in a valid state through default initializers. Any object that allocates memory for itself (or even for something else) should be a class, as you do not want to use them in an invalid state. There is no way to guarantee that a user will always call some sort of `init()` function on struct. That means that the author needs to be wary of any functions that he or she provides, as the onus is now on every function to verify whether the object is valid or not.

furthermore, the fact that a class object can clean up after itself through a destructor is also incredibly useful in preventing memory leaks.

Conceptually, it IS useful to have constructors: it prevents the need for some sort of init function. However, the problem arises when multiple options of constructing an object is provided. Jon Blow solves this exact problem by only allowing one constructor to be provided. This also solves the problem of what operator new is doing (i think? not sure!).


## Understanding Computer graphics
!!! WARNING










<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>